#!/usr/bin/env python3

##------------------------------------------------------------------------------
## Copyright (c) 2024 by European Organization for Nuclear Research (CERN)
## Author: Andreas-Joachim Peters / CERN EOS Project <andreas.joachim.peters@cern.ch>
##------------------------------------------------------------------------------
## This file is part of the XRootD software suite.
##
## XRootD is free software: you can redistribute it and/or modify
## it under the terms of the GNU Lesser General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.
##
## XRootD is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU Lesser General Public License
## along with XRootD.  If not, see <http://www.gnu.org/licenses/>.
##
## In applying this licence, CERN does not waive the privileges and immunities
## granted to it by virtue of its status as an Intergovernmental Organization
## or submit itself to any jurisdiction.
##------------------------------------------------------------------------------


import argparse
import os
import json
import string
import random
import uuid
import shutil
import re
import pwd
import ctypes
import ctypes.util
import errno

def main():
    # Create the main parser
    parser = argparse.ArgumentParser(prog='xs3')
    subparsers = parser.add_subparsers(dest='subcommand')

    # Add the 'config' subcommand
    config_parser = subparsers.add_parser('config', help='Configuration subcommand')
    config_parser.add_argument('--path', help='Path for config subcommand', default=None)
    config_parser.add_argument('--user', help='FS user to use to handle the configuration', default=None)

    # Add the 'adduser' subcommand
    adduser_parser = subparsers.add_parser('adduser', help='Add a new user')
    adduser_parser.add_argument('username', help='Username to add')
    adduser_parser.add_argument('bucketpath', help='Filesystem path for the default bucket for the given user') 
    adduser_parser.add_argument('--newbucketpath', help='New bucket path', default=None)

    # Add the 'deleteuser' subcommand
    deleteuser_parser = subparsers.add_parser('deleteuser', help='Delete an existing user')
    deleteuser_parser.add_argument('username', help='Username to delete')

    # Add the 'addbucket' subcommand
    addbucket_parser = subparsers.add_parser('addbucket', help='Add a new bucket')
    addbucket_parser.add_argument('username', help='Username')
    addbucket_parser.add_argument('bucketname', help='Bucket name')
    addbucket_parser.add_argument('bucketpath', help='Bucket path')

    # Add the 'deletebucket' subcommand
    deletebucket_parser = subparsers.add_parser('deletebucket', help='Delete an existing bucket')
    deletebucket_parser.add_argument('username', help='Username')
    deletebucket_parser.add_argument('bucketname', help='Bucket name')

    # Add the 'ls' subcommand
    ls_parser = subparsers.add_parser('ls', help='List users/buckets')
    ls_parser.add_argument('--username', help='Username',  default=None)
    ls_parser.add_argument('--keys',action='store_true', help='Show keys', default=False)
    # Parse the arguments
    args = parser.parse_args()

    # Handle the 'config' subcommand
    if args.subcommand == 'config':
        handle_config(args)
    elif args.subcommand == 'adduser':
        handle_adduser(args)
    elif args.subcommand == 'deleteuser':
        handle_deleteuser(args)
    elif args.subcommand == 'addbucket':
        handle_addbucket(args)
    elif args.subcommand == 'deletebucket':
        handle_deletebucket(args)
    elif args.subcommand == 'ls':
        handle_ls(args)
    else:
        parser.print_help()

libc_so = ctypes.util.find_library('c')
libc = ctypes.CDLL(libc_so, use_errno=True)

# ------------------------------------------------------------------------------
# Set the group identity used for filesystem checks. See setfsgid(2).
#
# Returns the previous group identity.
# ------------------------------------------------------------------------------
def setfsuid(fsuid):
    """Set user identity used for filesystem checks. See setfsuid(2)."""
    # Per the BUGS section in setfsuid(2), you can't really tell if a
    # setfsuid call succeeded. As a hack, we can rely on the fact that
    # setfsuid returns the previous fsuid and call it twice. The result
    # of the second call should be the desired fsuid.
    libc.setfsuid(ctypes.c_int(fsuid))
    new_fsuid = libc.setfsuid(ctypes.c_int(fsuid))

    # Fake an EPERM even if errno was not set when we can detect that
    # setfsuid failed.
    err = errno.EPERM if new_fsuid != fsuid else ctypes.get_errno()
    if err:
        raise OSError(err, os.strerror(err))


def setfsgid(fsgid):
    """Set grouop identity used for filesystem checks. See setfsgid(2)."""
    # Per the BUGS section in setfsgid(2), you can't really tell if a
    # setfsgid call succeeded. As a hack, we can rely on the fact that
    # setfsgid returns the previous fsuid and call it twice. The result
    # of the second call should be the desired fsuid.
    libc.setfsgid(ctypes.c_int(fsgid))
    new_fsgid = libc.setfsgid(ctypes.c_int(fsgid))

    # Fake an EPERM even if errno was not set when we can detect that
    # setfsuid failed.
    err = errno.EPERM if new_fsgid != fsgid else ctypes.get_errno()
    if err:
        raise OSError(err, os.strerror(err))


# ------------------------------------------------------------------------------
def print_directory_structure(directory, buckets_dir, indent=''):
    items = os.listdir(directory)
    for i, item in enumerate(items):
        item_path = os.path.join(directory, item)
        is_last = i == len(items) - 1

        if os.path.isdir(item_path):
            print(indent + ('└── ' if is_last else '├── ') + f"{item}/")
            print_directory_structure(item_path, indent + ('    ' if is_last else '│   '))
        else:
            bucket_file = os.path.join(buckets_dir, item)
            bucket_owner_attr = get_bucket_extended_attribute(bucket_file, 'user.s3.owner')
            bucket_path_attr = get_bucket_extended_attribute(bucket_file, 'user.s3.path')
            new_bucket_path_attr = get_extended_attribute(directory, 'user.s3.new_bucket_path')
            print(indent + ('└── ' if is_last else '├── ') + f"{item:20} {bucket_owner_attr:20} {bucket_path_attr:40} new:[{new_bucket_path_attr}]")

# ------------------------------------------------------------------------------
def get_extended_attribute(filepath, attribute_name):
    try:
        attr = os.getxattr(filepath, attribute_name)
        return attr.decode()
    except OSError:
        return ""

# ------------------------------------------------------------------------------
def get_bucket_extended_attribute(filename, attribute_name):
    base_path = os.path.join(os.path.expanduser('~'), '.xs3', 'buckets')
    file_path = os.path.join(base_path, filename)
    return get_extended_attribute(file_path, attribute_name)

# ------------------------------------------------------------------------------
def get_ids_from_username(username):
    try:
        # Get the user information from the username
        user_info = pwd.getpwnam(username)
        # Extract and return the UID,GID
        return user_info.pw_uid, user_info.pw_gid
    except KeyError:
        # Handle the case where the username does not exist
        print(f"Error: Username '{username}' not found.")
        return None

# ------------------------------------------------------------------------------
def change_fsid(new_fsuid, new_fsgid):
    try:
        # Check the current effective user ID
        current_euid = os.geteuid()
        current_egid = os.getegid()
        # Don't switch fsuid if we are not root
        if current_euid:
            return current_euid,current_egid

        # Set the new file system user ID
        old_fsuid = setfsuid(new_fsuid)
        old_fsgid = setfsgid(new_fsgid)
        return current_euid,current_egid

    except PermissionError as e:
        print(f"Error: PermissionError: {e}")
    except Exception as e:
        print(f"Error: An error occurred: {e}")

    return 0

# ------------------------------------------------------------------------------
def handle_config(args):

    # Determine the config directory and file path
    config_dir = os.path.join(os.path.expanduser('~'), '.xs3')
    config_file = os.path.join(config_dir, 'config')

    # If there is no path provided we print the config if existing
    # and exit
    if not args.path:
        if os.path.exists(config_file):
            with open(config_file, 'r') as f:
                config_data = json.load(f)
                print(json.dumps(config_data, indent=4))
            return
        else:
            print("Error: No path provided and no configuration file found.")
            return

    user = args.user;

    if user:
        uid,gid = get_ids_from_username(user)
        if uid is None:
            print(f"Error: Cannot translate username '{username}'.")
            return
    else:
        uid = 0
        gid = 0


    # Check if the config file already exists
    if os.path.exists(config_file):
        user_input = input(f"Question: Configuration file '{config_file}' already exists. Do you want to proceed and overwrite it? (yes/no): ")
        if user_input.lower() != 'yes':
            print("Info: Aborted by the user.")
            return
        
    base_path = args.path

    old_fsuid,old_fsgid = change_fsid(uid,gid)

    # Check if the path exists
    if not os.path.exists(base_path):
        try:
            # Create the directory
            os.makedirs(base_path)
            print(f"Info: Directory '{base_path}' created successfully.")
        except OSError as e:
            print(f"Error: Failed to create the directory '{base_path}'. {e}")
    else:
        print(f"Info: Directory '{base_path}' already exists.")

    # Define subdirectories to create
    subdirs = ['buckets', 'users', 'keystore']
    for subdir in subdirs:
        subdir_path = os.path.join(base_path, subdir)
        if not os.path.exists(subdir_path):
            try:
                os.makedirs(subdir_path)
                print(f"Info: Subdirectory '{subdir_path}' created successfully.")
            except OSError as e:
                print(f"Error: Failed to create the subdirectory '{subdir_path}'. {e}")
        else:
            print(f"Info: Subdirectory '{subdir_path}' already exists.")
 

    # Create the config directory if it doesn't exist
    if not os.path.exists(config_dir):
        try:
            os.makedirs(config_dir)
            print(f"Info: Config directory '{config_dir}' created successfully.")
        except OSError as e:
            print(f"Error: Failed to create the config directory '{config_dir}'. {e}")
            change_fsid(old_fsuid, old_fsgid)
            return

    print(old_fsuid,old_fsgid)
    change_fsid(old_fsuid,old_fsgid)

    # Write the base_path to the config file
    config_data = {'base_path': base_path, 'fsuid': uid, 'fsgid': gid}

    try:
        with open(config_file, 'w') as f:
            json.dump(config_data, f, indent=4)
        print(f"Info: Configuration saved to '{config_file}'.")
    except IOError as e:
        print(f"Error: Failed to write to the config file '{config_file}'. {e}")

# ------------------------------------------------------------------------------
def generate_unique_random_string(base_path, length=8):
    chars = string.ascii_letters + string.digits
    while True:
        random_string = ''.join(random.choice(chars) for _ in range(length))
        keystore_file = os.path.join(base_path, 'keystore', random_string)
        if not os.path.exists(keystore_file):
            return random_string

# ------------------------------------------------------------------------------
def handle_adduser(args):
    username = args.username
    bucket_path = args.bucketpath
    new_bucket_path = args.newbucketpath

    # Determine the users directory from the config file
    config_dir = os.path.join(os.path.expanduser('~'), '.xs3')
    config_file = os.path.join(config_dir, 'config')

    if not os.path.exists(config_file):
        print("Error: Configuration file does not exist. Please run 'config' subcommand first.")
        return

    try:
        with open(config_file, 'r') as f:
            config_data = json.load(f)
        base_path = config_data.get('base_path')
        fsuid = config_data.get('fsuid')
        fsgid = config_data.get('fsgid')
        if not base_path:
            print("Error: Base path is not configured properly.")
            return
    except (IOError, json.JSONDecodeError) as e:
        print(f"Error: Failed to read the config file '{config_file}'. {e}")
        return

    users_dir = os.path.join(base_path, 'users')
    if not os.path.exists(users_dir):
        print(f"Error: Users directory '{users_dir}' does not exist.")
        return

    old_fsuid,old_fsgid = change_fsid(fsuid,fsgid)

    # Create a user directory
    user_dir = os.path.join(users_dir, username)
    if os.path.exists(user_dir):
        print(f"Error: User '{username}' already exists.")
        change_fsid(old_fsuid,old_fsgid)
        return

    try:
        os.makedirs(user_dir)
        print(f"Info: User '{username}' added successfully.")

        if new_bucket_path:
            try:
                os.setxattr(user_dir, 'user.s3.new_bucket_path', new_bucket_path.encode())
                print(f"Info: Extended attribute 'user.s3.new_bucket_path' set on '{user_dir}': {new_bucket_path}")
            except AttributeError:
                print("info: Extended attributes are not supported on this platform.")
            except OSError as e:
                print(f"Error: Failed to set extended attribute on '{user_dir}'. {e}")

        # Create the empty file in the user directory
        user_file = os.path.join(user_dir, f"b_{username}")
        open(user_file, 'w').close()
        print(f"Info: Default bucket '{user_file}' assigned successfully.")

        # Create the same file in the buckets subdirectory
        buckets_dir = os.path.join(base_path, 'buckets')
        if not os.path.exists(buckets_dir):
            print(f"Error: Buckets directory '{buckets_dir}' does not exist.")
            change_fsid(old_fsuid,old_fsgid)
            return

        bucket_file = os.path.join(buckets_dir, f"b_{username}")
        open(bucket_file, 'w').close()
        print(f"Info: Default bucket '{bucket_file}' created successfully.")

        # Set the extended attribute 's3.user' on the bucket file
        try:
            os.setxattr(bucket_file, 'user.s3.owner', username.encode())
            print(f"Info: Extended attribute 'user.s3.owner' set on '{bucket_file}'.")
            os.setxattr(bucket_file, 'user.s3.path', bucket_path.encode())
            print(f"Info: Extended attribute 'user.s3.path' set on '{bucket_file}'.")
        except AttributeError:
            print("Error: Extended attributes are not supported on this platform.")
        except OSError as e:
            print(f"Error: Failed to set extended attribute on '{bucket_file}'. {e}")

        # Generate a unique human-friendly random string
        random_string = generate_unique_random_string(base_path)

        # Create the keystore file with UUID content
        keystore_file = os.path.join(base_path, 'keystore', random_string)
        with open(keystore_file, 'w') as f:
            uuid_value = uuid.uuid4()
            f.write(str(uuid_value))

        print(f"Info: Keystore file '{keystore_file}' created successfully.")

        # Set the extended attribute 's3.user' on the keystore file
        try:
            os.setxattr(keystore_file, 'user.s3.user', username.encode())
            print(f"Info: Extended attribute 'user.s3.user' set on '{keystore_file}'.")
      
        except AttributeError:
            print("Info: Extended attributes are not supported on this platform.")
        except OSError as e:
            print(f"Error: Failed to set extended attribute on '{keystore_file}'. {e}")

        print("User information:")
        print("-----------------")
        print(f"Username  : {username}")
        print(f"S3 Id     : {random_string}")
        print(f"S3 Secret : {uuid_value}")
    
    except OSError as e:
        print(f"Error: Failed to create the user directory '{user_dir} or bucket file 'b_{username}'. {e}")

    change_fsid(old_fsuid,old_fsgid)

# ------------------------------------------------------------------------------
def handle_deleteuser(args):
    username = args.username

    # Determine the users directory from the config file
    config_dir = os.path.join(os.path.expanduser('~'), '.xs3')
    config_file = os.path.join(config_dir, 'config')

    if not os.path.exists(config_file):
        print("Error: Configuration file does not exist. Please run 'config' subcommand first.")
        return

    try:
        with open(config_file, 'r') as f:
            config_data = json.load(f)
        base_path = config_data.get('base_path')
        fsuid = config_data.get('fsuid')
        fsgid = config_data.get('fsgid')
        if not base_path:
            print("Error: Base path is not configured properly.")
            return
    except (IOError, json.JSONDecodeError) as e:
        print(f"Error: Failed to read the config file '{config_file}'. {e}")
        return

    users_dir = os.path.join(base_path, 'users')
    user_dir = os.path.join(users_dir, username)

    if not os.path.exists(user_dir):
        print(f"Error: User '{username}' does not exist.")
        return

    # Ask for confirmation
    confirmation = input(f"Question: Are you sure you want to delete user '{username}' and all attached bucket configurations? (yes/no): ")
    if confirmation.lower() != 'yes':
        print("Info: Aborted by the user.")
        return

    old_fsuid,old_fsgid = change_fsid(fsuid,fsgid)

    # Delete user directory
    try:
        shutil.rmtree(user_dir)
        print(f"Info: User directory '{user_dir}' deleted successfully.")
    except OSError as e:
        print(f"Error: Failed to delete user directory '{user_dir}'. {e}")

    # Delete bucket file
    bucket_file = os.path.join(base_path, 'buckets', f"b_{username}")
    if os.path.exists(bucket_file):
        try:
            os.remove(bucket_file)
            print(f"Info: Default bucket file '{bucket_file}' deleted successfully.")
        except OSError as e:
            print(f"Error: Failed to delete bucket file '{bucket_file}'. {e}")

    # Delete additinoal bucket files with 's3.owner' set to username
    buckets_dir = os.path.join(base_path, 'buckets')
    for filename in os.listdir(buckets_dir):
        filepath = os.path.join(buckets_dir, filename)
        try:
            # Check if the file has 's3.owner' extended attribute and matches the username
            owner_attr = os.getxattr(filepath, 'user.s3.owner')
            if owner_attr.decode() == username:
                os.remove(filepath)
                print(f"info: Bucket file '{filepath}' deleted successfully.")
        except OSError as e:
            print(f"Error: Failed to delete bucket file '{filepath}'. {e}")
        except KeyError:
            pass  # File does not have 's3.owner' extended attribute

    # Delete keystore file
    keystore_dir = os.path.join(base_path, 'keystore')
    for filename in os.listdir(keystore_dir):
        filepath = os.path.join(keystore_dir, filename)
        try:
            # Check if the file has 's3.user' extended attribute and matches the username
            user_attr = os.getxattr(filepath, 'user.s3.user')
            if user_attr.decode() == username:
                os.remove(filepath)
                print(f"Info: Keystore file '{filepath}' deleted successfully.")
        except OSError as e:
            print(f"Error: Failed to delete keystore file '{filepath}'. {e}")
        except KeyError:
            pass  # File does not have 's3.user' extended attribute

    print(f"Info: User '{username}' deleted successfully.")

    change_fsid(old_fsuid,old_fsgid)

def validate_bucket_name(name):
    if len(name) < 3 or len(name) > 63:
        return False

    if not name[0].isalnum() or not name[-1].isalnum():
        return False

    return all(c.islower() or c.isdigit() or c == '.' or c == '-' for c in name)

# ------------------------------------------------------------------------------
def handle_addbucket(args):
    username = args.username
    bucketname = args.bucketname
    bucketpath = args.bucketpath

    # Validate the bucket name
    if not validate_bucket_name(bucketname):
        print("Error: Invalid bucket name. Bucket names must be 3-63 characters long, start and end with alphanumeric characters, and contain only lowercase letters, digits, dots, and hyphens.")
        return
    
    # Determine the base path from the config file
    config_dir = os.path.join(os.path.expanduser('~'), '.xs3')
    config_file = os.path.join(config_dir, 'config')

    if not os.path.exists(config_file):
        print("Error: Configuration file does not exist. Please run 'config' subcommand first.")
        return

    try:
        with open(config_file, 'r') as f:
            config_data = json.load(f)
        base_path = config_data.get('base_path')
        fsuid = config_data.get('fsuid')
        fsgid = config_data.get('fsgid')
        if not base_path:
            print("Error: Base path is not configured properly.")
            return
    except (IOError, json.JSONDecodeError) as e:
        print(f"Error: Failed to read the config file '{config_file}'. {e}")
        return

    old_fsuid,old_fsgid = change_fsid(fsuid,fsgid)

    # Check if the bucket file already exists
    buckets_dir = os.path.join(base_path, 'buckets')
    bucket_file = os.path.join(buckets_dir, bucketname)
    if os.path.exists(bucket_file):
        try:
            owner_attr = os.getxattr(bucket_file, 'user.s3.owner')
            path_attr = os.getxattr(bucket_file, 'user.s3.path')
            owner = owner_attr.decode()
            path = path_attr.decode()
            print(f"Error: Bucket '{bucketname}' already exists. Owner: {owner}, Path: {path}")
        except OSError as e:
            print(f"Error: Failed to retrieve extended attributes from bucket file '{bucket_file}'. {e}")
        change_fsid(old_fsuid,old_fsgid)
        return

    # Check if the user directory exists
    users_dir = os.path.join(base_path, 'users')
    user_dir = os.path.join(users_dir, username)
    if not os.path.exists(user_dir):
        print("Error: User does not exist - use 'adduser' first.")
        change_fsid(old_fsuid,old_fsgid)
        return

    # Create an empty file under the users directory with the username
    user_bucket_file = os.path.join(user_dir, bucketname)
    if not os.path.exists(user_bucket_file):
        try:
            with open(user_bucket_file, 'w') as f:
                f.write('')
            print(f"Info: Empty file '{user_bucket_file}' created successfully under users directory.")
        except OSError as e:
            print(f"Error: Failed to create empty file '{user_bucket_file}' under users directory. {e}")

    # Create the bucket directory
    buckets_dir = os.path.join(base_path, 'buckets')
    bucket_file = os.path.join(buckets_dir, bucketname)

    # Create or update the bucket file
    try:
        with open(bucket_file, 'w') as f:
            f.write('')
        print(f"Info: New bucket file '{bucket_file}' created successfully.")
    except OSError as e:
        print(f"Error: Failed to create or update bucket file '{bucket_file}'. {e}")
        return

    # Set extended attributes on the bucket file
    try:
        os.setxattr(bucket_file, 'user.s3.owner', username.encode())
        os.setxattr(bucket_file, 'user.s3.path', bucketpath.encode())
        print(f"Info: Extended attributes set on '{bucket_file}': 'user.s3.owner'={username}, 'user.s3.path'={bucketpath}")
    except AttributeError:
        print("Info: Extended attributes are not supported on this platform.")
    except OSError as e:
        print(f"Error: Failed to set extended attributes on '{bucket_file}'. {e}")

    change_fsid(old_fsuid,old_fsgid)

# ------------------------------------------------------------------------------
def handle_deletebucket(args):
    username = args.username
    bucketname = args.bucketname

    # Determine the base path from the config file
    config_dir = os.path.join(os.path.expanduser('~'), '.xs3')
    config_file = os.path.join(config_dir, 'config')

    if not os.path.exists(config_file):
        print("Error: Configuration file does not exist. Please run 'config' subcommand first.")
        return

    try:
        with open(config_file, 'r') as f:
            config_data = json.load(f)
        base_path = config_data.get('base_path')
        fsuid = config_data.get('fsuid')
        fsgid = config_data.get('fsgid') 
        if not base_path:
            print("Error: Base path is not configured properly.")
            return
    except (IOError, json.JSONDecodeError) as e:
        print(f"Error: Failed to read the config file '{config_file}'. {e}")
        return

    old_fsuid,old_fsgid = change_fsid(fsuid,fsgid)

    # Check if the user directory exists
    users_dir = os.path.join(base_path, 'users')
    user_dir = os.path.join(users_dir, username)
    if not os.path.exists(user_dir):
        print("Error: User does not exist - use adduser first.")
        change_fsid(old_fsuid,old_fsgid)
        return

    # Check if the bucket file exists
    buckets_dir = os.path.join(base_path, 'buckets')
    bucket_file = os.path.join(buckets_dir, bucketname)
    if not os.path.exists(bucket_file):
        print(f"Error: Bucket '{bucketname}' does not exist.")
        change_fsid(old_fsuid,old_fsgid)
        return

    # Check if the user is the owner of the bucket
    try:
        owner_attr = os.getxattr(bucket_file, 'user.s3.owner')
        if owner_attr.decode() != username:
            print("Error: User is not the owner of the given bucket.")
            change_fsid(old_fsuid,old_fsgid)
            return
    except OSError as e:
        print(f"Error: Failed to retrieve extended attribute from bucket file '{bucket_file}'. {e}")
        change_fsid(old_fsuid,old_fsgid)
        return

    # Delete the bucket file
    try:
        os.remove(bucket_file)
        print(f"Info: Bucket file '{bucket_file}' deleted successfully.")
    except OSError as e:
        print(f"Error: Failed to delete bucket file '{bucket_file}'. {e}")

    # Delete the empty file under the users directory with the bucket name
    user_bucket_file = os.path.join(user_dir, bucketname)
    if os.path.exists(user_bucket_file):
        try:
            os.remove(user_bucket_file)
            print(f"Info: Empty file '{user_bucket_file}' deleted successfully from users directory.")
        except OSError as e:
            print(f"Error: Failed to delete empty file '{user_bucket_file}' from users directory. {e}")

    change_fsid(old_fsuid,old_fsgid)

# ------------------------------------------------------------------------------
def handle_ls(args):
    username = args.username

    # Determine the users directory from the config file
    config_dir = os.path.join(os.path.expanduser('~'), '.xs3')
    config_file = os.path.join(config_dir, 'config')

    if not os.path.exists(config_file):
        print("Error: Configuration file does not exist. Please run 'config' subcommand first.")
        return

    try:
        with open(config_file, 'r') as f:
            config_data = json.load(f)
        base_path = config_data.get('base_path')
        fsuid = config_data.get('fsuid')
        fsgid = config_data.get('fsgid')
        users_dir = os.path.join(base_path, 'users')
        buckets_dir = os.path.join(base_path, 'buckets')
        keys_dir = os.path.join(base_path, 'keystore')
        if not base_path:
            print("Error: Base path is not configured properly.")
            return
    except (IOError, json.JSONDecodeError) as e:
        print(f"Error: Failed to read the config file '{config_file}'. {e}")
        return

    old_fsuid,old_fsgid = change_fsid(fsuid,fsgid)

    if (args.keys):
        if username:
            regex = re.compile(username)
        print("Info: Listing matching keys:")

        print("---------------  --------------------- ------------------------------------")
        print("USER             ID                    SECRET")
        print("---------------  --------------------- ------------------------------------")
        for key_name in os.listdir(keys_dir):
            key_file = os.path.join(keys_dir, key_name)
            s3user = get_extended_attribute(key_file, 'user.s3.user')
            if ( not username ) or (username and regex.match(s3user)):
                with open(key_file, 'r') as file:
                # Read the content of the file
                    secret = file.read()
                print(f"{s3user:16} {key_name:21} {secret:40}")
    else:
        if username:
            regex = re.compile(username)
            print("Info: Listing matching user directories:")
            for dir_name in os.listdir(users_dir):
                if regex.match(dir_name):
                    user_dir = os.path.join(users_dir, dir_name)
                    print(f"- {dir_name}/")
                    print_directory_structure(user_dir, buckets_dir, '    ')
        else:
            print("Info: Listing all user directories:")
            for dir_name in os.listdir(users_dir):
                user_dir = os.path.join(users_dir, dir_name)
                print(f"{dir_name}/")
                print_directory_structure(user_dir, buckets_dir,  '    ')

    change_fsid(old_fsuid,old_fsgid)

# ------------------------------------------------------------------------------
if __name__ == '__main__':
    main()
    
